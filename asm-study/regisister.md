> 这部分用于记录汇编语言中寄存器的一些知识

# 常见寄存器
> 寄存器按照用途可以分为通用寄存器，段寄存器等

## 通用寄存器
> 在8086中有4个通用寄存器:AX,BC,CX,DX,他们是16位的寄存器，每一个寄存器都可以分为两个8位寄存器，分别位XH，XL，例如AX可以分成两个AH，AL

## 段寄存器
> 程序中会对代码进行分段，整体分为<b>数据段, 代码段</b>这两个段，其他段都是在这两个段的基础上进行细分形成的，而在进行地址访问的时候，地址是以<b>段基地址：段内偏移地址</b>的形式给出，这里就需要寄存器存储这两个地址，有4个段基地址寄存器：CS，DS，SS，ES，常用的偏移地址寄存器位SI，DI，IP

### 代码段寄存器
> CS:IP这两个寄存器用于存放CPU当前要执行的命令的地址，对应于我们常说的程序计数器（PC）

#### 利用寄存器执行命令的过程
1. 从CS：IP指向的地址取出指令放入指令缓存器
2. 修改IP的值：IP+步骤1取出的指令长度
3. 执行指令，跳转到步骤1

#### 修改CS：IP的值
> 不能使用mov指令对这两个寄存器修改，想要修改就需要使用jmp指令
1. jmp 段基地址：偏移地址同时修改CS:IP,例如
```
    jmp 2AE3:4 CS=2AE3 IP=4
```
2. jmp 寄存器 只修改IP
```
    jmp ax
```
### 数据段寄存器
> 前面讲解的是CPU如何区指令，那么这一节讲解CPU如何读写数据，这里通过数据段相关的寄存器实现

#### 数据段寄存器DS
> 8086支持从内存单元与寄存器之间的数据传送，内存单元只能使用段基地址：偏移量的形式给出，命令格式如下
```
    mov ax, [base:offset]
    mov ax, [offset]
```
> 默认情况下base由ds寄存器指定，此时可以使用第二种的精简形式的指令，如果使用其他寄存器如ES，那么必须使用 ***base:offset***的形式。示例代码
```
// 使用ds数据段寄存器
mov ax， 1000h
mov ds, ax    // 设置数据段基址寄存器

mov cx [3] // 将 1000h:3h 处的内容存入cx寄存器，此处完整形式[ds:3],由于默认就是使用ds做基址，可省略

// 使用其他寄存器，以es扩展寄存器为例

mov ax, 1000h
mov es, ax

mov cx [es:3]   // 此处必须明确指出基址寄存器
```
##### 注
> 使用[]这种形式提供偏移地址时，有规定只能使用数字或几个特定的寄存器提供偏移地址：bp, bx，si,di,这四个寄存器可以单独出现，或者只能以四种组合出现：bx和si、bx和di、bp和si、bp和di

1. SI是源变址寄存器：用于源操作数的偏移,
2. DI是目的寄存器:用于目的操作数的偏移
3. bp :栈基址寄存器，这是用于函数栈的基址，一般配合sp寄存器使用，后面会在SS寄存器说明
```
mov ax,[bx]
mov ax,[si]
mov ax,[di]
mov ax,[bp]
mov ax,[bx+si]
mov ax,[bx+di]
mov ax,[bp+si]
mpv ax,[bp+di]
mov ax,[bx+si+idata]
mov ax,[bx+si+idata]
mov ax,[bp+si+idata]
mov ax,[bp+di+idata]
```
> 用BX, SI, DI这三个寄存器作为偏移量寄存器时，都缺省使用DS作为段寄存器。

### 栈基址寄存器SS
> 栈是一种特殊的结构,使用SS：SP的形式指定栈顶元素，这里还有一个bp寄存器，这个寄存器是用于指定某一个函数栈在SS寄存器中的基地址，也就是说是以SS寄存器作为基址寄存器的，通常和SP搭配用于说明当前函数栈的范围



### 注
> 在32位机器中，寄存器开头都加上一个E，例如AX变为EAX,在64位机器上,寄存器开头都加一个R，例如AX变为RAX